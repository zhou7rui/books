# 信息的表示和处理

本章我们研究在计算机上如何表示数字和其他形式数据的的基本属性，以及计算机对这些数据执行操作的的属性。这些要求我们深入学习语言，编写公式和方程式，以及展示重要属性的推导。

现代计算机存储和处理的信息以二进制信号表示。 这些微不足道的二进制数字，或者称为位（bit）。（**源程序实际就是一个由值0和1组成的位（又称比特）序列，8个位被组成一组称为字节。**）

## 信息的表示

**无符号（unsigned）编码**基于传统的二进制表示法 ，表示大于或者等于零的数字。

**补码（two's-complement）编码**是表示有符号整数的最常见的方式，**有符号**整数就是可以为正或者为负的数字。

**浮点数（floating-point）编码**是表示实数的科学记数法的以2为基数的版本。

### 信息存储

大多数计算机使用8位的块，或者字节（byte）,作为最小的可寻址的内存，而不是访问内存中单纯的位。机器级程序将内存视为一个超大的字节数组，称为虚拟内存（virtual memory）。 内存中每一个字节都是由一个唯一的数字来标识，称为它的地址（ad-dress），/*脑中回想C语言中指针*/ 所有可能的集合就称为虚拟地址空间（virtual addres space）。

###十六机制表示法：

二进制表示太过冗长，而我们常用十进制与位模式的相互转换比较转化很麻烦。  当遇到这种问题：Any problem  in computer science can be solved by anther layer of indirection.（**计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决**）。通过十六机制表示:开头 0~9使用数字，后面使用'A'~'F'表示。下面是十六进制的对照表

|  十机制  |  0   |  1   |  2   |  3   |
| :------: | :--: | :--: | :--: | :--: |
|  二进制  | 0000 | 0001 | 0010 | 0011 |
| 十六机制 |  0   |  1   |  2   |  3   |
|  十进制  |  4   |  5   |  6   |  7   |
|  二进制  | 0100 | 0101 | 0110 | 0111 |
| 十六进制 |  4   |  5   |  6   |  7   |
|  十进制  |  8   |  9   |  10  |  11  |
|  二进制  | 1000 | 1001 | 1010 | 1011 |
| 十六进制 |  8   |  9   |  A   |  B   |
|  十进制  |  12  |  13  |  14  |  15  |
|  二进制  | 1100 | 1101 | 1110 | 1111 |
| 十六进制 |  C   |  D   |  E   |  F   |

### 字数据大小

每台计算机都有一个字长（word size），字长决定这虚拟空间的最大大小。范围为0-2^w-1，最多访问2^w个字节。 对于32位的系统最多能访问2^32个字节。就是刚好4GB的虚拟空间（就是为啥32位的电脑内存只支持4GB）

​																C数据类型中32位和64位的典型值

|         |                |      |      |
| :-----: | :------------: | :--: | :--: |
| 有符号  |     无符号     |  32  |  64  |
|  char   | unsigned char  |  1   |  1   |
|  short  | unsigned short |  2   |  2   |
|   int   |    unsigned    |  4   |  4   |
|  long   |  unsigned log  |  4   |  8   |
| Int32_t |   unint32_t    |  4   |  4   |
| int64_t |   unint64_t    |  8   |  8   |
| char *  |                |  4   |  8   |
|  float  |                |  4   |  4   |
| dobule  |                |  8   |  8   |

### 字节顺序

机器选择内存中按照从低到高有效顺序存储对象。被称为**小端法**

机器选择内存中按照从高到低有效顺序存储对象。被称为**大端法**

常见 Android 和 iOS都是才用的小端法

字节序的处理，就是一句话：**只有读取的时候，才必须区分字节序，其他情况都不用考虑**

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start,size_t len){

    size_t i;

    for(i = 0; i < len; i += 1){
        printf(" %.2x", start[i]);
    }
    printf("\n");

}

void show_int(int x){

    show_bytes((byte_pointer) &x, sizeof(int));
}

void show_float(float x){
    show_bytes((byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x){
    show_bytes((byte_pointer) &x, sizeof(void *));
}

int main(){
  show_float(100.0);
  return 1;
}

```

可以通过上述程序打印出字节的表示。

### 布尔代数以及位级运算

​		0110				0110				 0110	                 1100

&	 1101			|  1100			^   1100    			~  --------

​		0100				1110				 1010					0011

^ 异或：一真一假才为值

C语言中的逻辑运算 ||、&&、！， || 和 |，&& 和& 区别是，如果对第一个参数求值就能确定表达式的结果， 那么逻辑运算符就不会对第二个参数求值。 && 和 || 都具有断路的左右。

移位计算：

| 操作                      |              值               |
| ------------------------- | :---------------------------: |
| 参数x                     |   [0110 0011]  [1001 0101]    |
| x << 4                    |  [0011 *0000*] [0101 *0000*]  |
| x >> 4 （逻辑右移 x>>>4） |  [*0000* 0110] [*0000* 1001]  |
| x >> 4   (算术右移)       | [*0000* 0110] [**1111** 1001] |

 x >> k逻辑右移在左端补k个0,算术右移会根据左端k个最高有效位的值补充对应值。

**Java 中 x >> k 会将x算术右移k个位置， x >>> k 会将x 做逻辑右移**。



### 整数表示 整数运算  浮点数

// todo  练习题刷过后补上

里面涉及大量的数学公式，看得有点云里雾里的，感觉需要配合练习题食用才有效果， 里面举的例子 Free BSD 中 函数getpeername的安全漏洞的例子中 意识到理解 整数的表示 中无符号数和补码中转换关系 的重要性。 

浮点表示通过数字编码为 x* 2^y 的形式来近似地表示实数。



